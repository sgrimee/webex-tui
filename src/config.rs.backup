// config.rs

// credits: iRigellute/spotify-tui

use color_eyre::eyre::{eyre, Error, Result};
use log::{info, warn};
use serde::{Deserialize, Serialize};
use std::{
    env,
    fs,
    io::{stdin, Write},
    path::{Path, PathBuf},
};

const DEFAULT_PORT: u16 = 8080;
const CLIENT_FILE_NAME: &str = "client.yml";
const USER_FILE_NAME: &str = "config.yml";
const CONFIG_DIR: &str = ".config";
const APP_CONFIG_DIR: &str = "webex-tui";

fn default_theme_name() -> String {
    "default".to_string()
}

fn default_messages_to_load() -> u32 {
    10
}

fn default_port() -> u16 {
    DEFAULT_PORT
}

#[derive(Default, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub(crate) struct ClientConfig {
    pub(crate) client_id: String,
    pub(crate) client_secret: String,
    // FIXME: port should be defined in `user_config` not in here
    pub(crate) port: Option<u16>,
}

/// User preferences configuration (managed by nix/user)
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub(crate) struct UserConfig {
    /// OAuth2 redirect port
    #[serde(default = "default_port")]
    pub(crate) port: u16,
    /// Theme name to load from themes directory
    #[serde(default = "default_theme_name")]
    pub(crate) theme: String,
    /// Number of messages to load per room
    #[serde(default = "default_messages_to_load")]
    pub(crate) messages_to_load: u32,
    /// Enable debug logging by default
    #[serde(default)]
    pub(crate) debug: bool,
}

impl Default for UserConfig {
    fn default() -> Self {
        Self {
            port: default_port(),
            theme: default_theme_name(),
            messages_to_load: default_messages_to_load(),
            debug: false,
        }
    }
}

struct ConfigPaths {
    pub(crate) client_config_path: PathBuf,
    pub(crate) user_config_path: PathBuf,
    pub(crate) app_config_dir: PathBuf,
}

impl ClientConfig {
    pub(crate) fn new() -> ClientConfig {
        ClientConfig {
            client_id: "".to_string(),
            client_secret: "".to_string(),
            port: None,
        }
    }

    /// Returns the path(s) to config files, creating them if needed.
    fn get_or_build_paths(&self) -> Result<ConfigPaths> {
        match dirs::home_dir() {
            Some(home) => {
                let path = Path::new(&home);
                let home_config_dir = path.join(CONFIG_DIR);
                let app_config_dir = home_config_dir.join(APP_CONFIG_DIR);

                if !home_config_dir.exists() {
                    fs::create_dir(&home_config_dir)?;
                }

                if !app_config_dir.exists() {
                    fs::create_dir(&app_config_dir)?;
                }

                let client_config_path = app_config_dir.join(CLIENT_FILE_NAME);
                let user_config_path = app_config_dir.join(USER_FILE_NAME);

                let paths = ConfigPaths {
                    client_config_path,
                    user_config_path,
                    app_config_dir,
                };

                Ok(paths)
            }
            None => Err(eyre!("No $HOME directory found for client config")),
        }
    }

    /// Reads the configuration from the config file if it exists.
    /// If it doesn't, prompt the user to enter the integration credentials
    /// and save them to the configuration file.
    pub(crate) fn load_config(&mut self) -> Result<()> {
        let paths = self.get_or_build_paths()?;
        if paths.client_config_path.exists() {
            let config_string = fs::read_to_string(&paths.client_config_path)?;
            let config_yml: ClientConfig = serde_yaml::from_str(&config_string)?;

            self.client_id = config_yml.client_id;
            self.client_secret = config_yml.client_secret;
            self.port = config_yml.port;

            Ok(())
        } else {
            println!(
                "Client config will be saved to {}",
                paths.client_config_path.display()
            );

            println!("\nHow to get setup:\n");

            let instructions = [
                "Go to the webex integrations page - https://developer.webex.com/docs/integrations",
                "Click `Create an Integration`",
                "Set the integration name to webex-tui",
                "Pick any icon",
                "Add a description of 10+ characters (for example sgrimee/webex-tui)",
                &format!(
                    "Add `http://localhost:{}` to the Redirect URI(s)",
                    DEFAULT_PORT
                ),
                "Under `Scopes`, check `spark:all`",
                "At the bottom, click `Add Integration`",
                "Enter the `Client ID` and `Client Secret` you will get below.",
                "Then your browser should open for the authentication to Webex.",
            ];

            let mut number = 1;
            for item in instructions.iter() {
                println!("  {}. {}", number, item);
                number += 1;
            }

            const EXPECTED_CID_LEN: usize = 65;
            let client_id = ClientConfig::get_client_key_from_input("Client ID", EXPECTED_CID_LEN)?;
            const EXPECTED_CS_LEN: usize = 64;
            let client_secret =
                ClientConfig::get_client_key_from_input("Client Secret", EXPECTED_CS_LEN)?;

            let port = DEFAULT_PORT;

            let config_yml = ClientConfig {
                client_id,
                client_secret,
                port: Some(port),
            };

            let content_yml = serde_yaml::to_string(&config_yml)?;

            let mut new_config = fs::File::create(&paths.client_config_path)?;
            write!(new_config, "{}", content_yml)?;

            self.client_id = config_yml.client_id;
            self.client_secret = config_yml.client_secret;
            self.port = config_yml.port;

            Ok(())
        }
    }

    /// Gets a string typed by the user on the terminal and performs
    /// basic validation.
    fn get_client_key_from_input(
        type_label: &'static str,
        expected_length: usize,
    ) -> Result<String> {
        let mut client_key = String::new();
        const MAX_RETRIES: u8 = 5;
        let mut num_retries = 0;
        loop {
            println!("\nEnter your {}: ", type_label);
            stdin().read_line(&mut client_key)?;
            client_key = client_key.trim().to_string();
            match ClientConfig::validate_client_key(&client_key, expected_length) {
                Ok(_) => return Ok(client_key),
                Err(error_string) => {
                    println!("{}", error_string);
                    client_key.clear();
                    num_retries += 1;
                    if num_retries == MAX_RETRIES {
                        return Err(Error::from(std::io::Error::new(
                            std::io::ErrorKind::Other,
                            format!("Maximum retries ({}) exceeded.", MAX_RETRIES),
                        )));
                    }
                }
            };
        }
    }

impl UserConfig {
    /// Load user configuration with multiple fallback methods:
    /// 1. Environment variable WEBEX_TUI_CONFIG pointing to a file
    /// 2. Nix-generated config file at ~/.config/webex-tui/config.yml
    /// 3. Default values if no config found
    pub(crate) fn load() -> Self {
        // Try environment variable first (nix can set this)
        if let Ok(config_path) = env::var("WEBEX_TUI_CONFIG") {
            info!("Loading user config from WEBEX_TUI_CONFIG: {}", config_path);
            if let Ok(config) = Self::load_from_file(Path::new(&config_path)) {
                return config;
            }
            warn!("Failed to load config from WEBEX_TUI_CONFIG, trying default location");
        }

        // Try standard location
        if let Some(home) = dirs::home_dir() {
            let config_path = home
                .join(CONFIG_DIR)
                .join(APP_CONFIG_DIR)
                .join(USER_FILE_NAME);
            
            info!("Loading user config from: {}", config_path.display());
            if let Ok(config) = Self::load_from_file(&config_path) {
                return config;
            }
        }

        // Use defaults if no config found
        info!("No user config found, using defaults");
        Self::default()
    }

    /// Load configuration from a specific file
    fn load_from_file(path: &Path) -> Result<Self> {
        let content = fs::read_to_string(path)?;
        let config: UserConfig = serde_yaml::from_str(&content)?;
        Ok(config)
    }

    /// Get the OAuth2 redirect port, with backwards compatibility for legacy client.yml
    pub(crate) fn get_port(&self, _client_config: &ClientConfig) -> u16 {
        // For backwards compatibility, check if client.yml has a port
        if let Ok(paths) = self.get_paths() {
            if let Ok(content) = fs::read_to_string(&paths.client_config_path) {
                if let Ok(legacy_config) = serde_yaml::from_str::<serde_yaml::Value>(&content) {
                    if let Some(port) = legacy_config.get("port").and_then(|p| p.as_u64()) {
                        warn!("Using port from legacy client.yml ({}). Consider moving to config.yml", port);
                        return port as u16;
                    }
                }
            }
        }
        self.port
    }

    fn get_paths(&self) -> Result<ConfigPaths> {
        match dirs::home_dir() {
            Some(home) => {
                let path = Path::new(&home);
                let home_config_dir = path.join(CONFIG_DIR);
                let app_config_dir = home_config_dir.join(APP_CONFIG_DIR);
                let client_config_path = app_config_dir.join(CLIENT_FILE_NAME);
                let user_config_path = app_config_dir.join(USER_FILE_NAME);

                Ok(ConfigPaths {
                    client_config_path,
                    user_config_path,
                    app_config_dir,
                })
            }
            None => Err(eyre!("No $HOME directory found")),
        }
    }
}
            };
        }
    }

    /// Performs basic validation on a key, ensuring it is an hexadecimal string
    /// of given `expected_length`.
    fn validate_client_key(key: &str, expected_length: usize) -> Result<()> {
        if key.len() != expected_length {
            Err(Error::from(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                format!(
                    "invalid length: {} (must be {})",
                    key.len(),
                    expected_length,
                ),
            )))
        } else if !key.chars().all(|c| c.is_ascii_hexdigit()) {
            Err(Error::from(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "invalid character found (must be hex digits)",
            )))
        } else {
            Ok(())
        }
    }
}
